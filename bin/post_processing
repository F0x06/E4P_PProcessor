#!/bin/bash
#
# elphel-parallel-processing - Elphel camera array images post processing using GNU parallel
#
# Copyright (c) 2013-2014 FOXEL SA - http://foxel.ch
# Please read <http://foxel.ch/license> for more information.
#
# Author(s):
#
#      Luc Deschenaux <l.deschenaux@foxel.ch>
#      Kevin Velickovic <k.velickovic@foxel.ch>
#
# This file is part of the FOXEL project <http://foxel.ch>.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
# Additional Terms:
#
#      You are required to preserve legal notices and author attributions in
#      that material or in the Appropriate Legal Notices displayed by works
#      containing it.
#
#      You are required to attribute the work as explained in the "Usage and
#      Attribution" section of <http://foxel.ch/license>.

set -e

[ -n "$DEBUG" ] && set -x

usage() {

  if [ "$1" == "-h" ] ; then
    echo "$(basename $0) [-h|--help] [OPTION...] <sourceDir>  <destDir> [ -o <script> ]"
    exit 1
  fi

  cat | less << EOF 
SYNOPSIS:

    $(basename $0) [OPTION...] <sourceDir>  <destDir> [ -o <script> ]

DESCRIPTION:

    Generate a script to process unprocessed files from <sourceDir> and place
    the resulting files in <destDir>, using GNU parallel. 

CONSTRAINTS:

    You must specify GNU parallel options after the output script name, or
    they can be specified in the PARALLEL environment variable.

QUEUE MODE:

    If no output script name, or option --run is set, the processing is started
    immediately (before the full list of timestamps is built), using the output
    script as a queue, until "EOQ" is queued

RESUME PROCESSING:

    To resume processing, run the output script again.

OPTIONS SUMMARY:
    -h,--help                   display this
    -s,--shuffle                process progressively instead of sequentially
    -o,--output <script>        set output script name
    -r,--run                    start processing immediately in queue mode
    -p,--parallel <options>     when -r is specified, set gnu parallel options
    -l,--logdir <path>          set log directory

    -x,--xml <path>             imagej-elphel xml preferences path
    -m,--mem <memory>           memory to allocate for ImageJ
    -S,--split-at <count>       Split configuration files. Default is 9
    -t,--truncate               eg if split == 8 and you dont want the
                                9th channel in the next xml
    -M,--folder-max             maximum number of files per output directory
EOF
  exit 1
  echo "Usage: $(basename $0) [ -s | --shuffle ] <eyesis_correction_xml> <source_dir> [ <results_dir>  <output_script> <split_at> <truncate> ]"
  echo
  echo "- When no output file is specified, parallel is run immediately"
  echo "- Paths for corrxml can be specified as environment variables"
  echo "- IMAGEJMEM, REMOTELOGGER, FILELIST, LOGDIR, REMOTESCRIPT too"
  echo "- <split_at> defaults to 9. When you want only the 8 first channels"
  echo "  per timestamp then set <split_at> to 8 and <truncate> to true"
  echo "- use --shuffle to process timestamps by half steps"
  echo
  exit 1

} # usage

init() {
 
  checkdependencies
 
  [ $# -lt 1 ] && usage -h
                                                                                                                                                                                                                   
  # parse command line options
  if ! options=$(getopt -o hso:rp:l:x:m:M:f:tS: -l help,shuffle,output:,run,parallel:,logdir,xml,mem,folder-max,filelist:,truncate,split-at: -- "$@")
  then
      # something went wrong, getopt will put out an error message for us
      exit 1
  fi
 
  eval set -- "$options"
 
  while [ $# -gt 0 ] ; do
      case $1 in
      -h|--help) usage $1 ;;
      -s|--shuffle) SHUFFLE="yes" ;;
      -o|--output) OUTPUT=$2 ; shift ;;
      -r|--run) RUN=yes ;;
      -p|--parallel) export PARALLEL=$2 ; shift ;;
      -l|--logdir) LOGDIR=$2 ; shift ;;
      -x|--xml) XML=$2 ; shift ;;
      -m|--mem) IMAGEJMEM=$2 ; shift ;;
      -M|--folder-max) FOLDER_MAX=$2 ; shift ;;
      -f|--filelist) FILELIST=$2 ; shift ;;
      -S|--split-at) SPLITAT=$2 ; shift ;;
      -t|--truncate) TRUNCATE=yes ;;
      (--) shift; break;;
      (-*) echo "$(basename $0): error - unrecognized option $1" 1>&2; exit 1;;
      (*) break;;
      esac
      shift
  done
 
  [ $# -lt 2 ] && usage -h
 
  SRCDIR=$(realpath "$1")
  DSTDIR=$(realpath "$2")
  
  # default values
  [ -z "$SPLITAT" ] && SPLITAT=9  # channels per job (xml)
  [ -z "$IMAGEJMEM" ] && IMAGEJMEM=7150m
  [ -z "$FOLDER_MAX" ] && FOLDER_MAX=90000

  # current timestamp
  NOW=$(date +%s) # _%N

  # if no output script name specified
  # 1. first generate one,
  # 2. ask to run parallel with this file as job queue, without waiting for the complete list
  if [ -z "$OUTPUT" ] ; then
       OUTPUT="post_processing-$NOW"
       RUN=true
  fi

  # set logdir if not specified as environment variable
  [ -z "$LOGDIR" ] && LOGDIR=log/post_processing
  mkdir -p $LOGDIR

  # set remotescript if not specified as environment variable
  if [ -z "$REMOTESCRIPT" ] ; then
    REMOTESCRIPT=$(which post_process.sh)
    REMOTESCRIPT=${REMOTESCRIPT#$HOME/}
  fi

  [ -z "$REMOTESCRIPT" ] && REMOTESCRIPT=bin/post_process.sh
  mkdir -p $SRCDIR/../post_processing

  if [ -z "$REMOTELOGGER" ] ; then
    REMOTELOGGER=$(which paralog.sh)
    REMOTELOGGER=${REMOTELOGGER#$HOME/}
  fi

  [ -z "$REMOTELOGGER" ] && REMOTELOGGER=remote-scripts/paralog.sh

  # set parallelbang path
  if [ -z "$PBANG" ] ; then
    PBANG=$(which parallelbang)
    PBANG=${PBANG#$HOME/}
  fi

  [ -z "$PBANG" ] && PBANG=bin/parallelbang

  cd $HOME
}

main() {
   
  init "$@"
   
  # generate hashbang
  echo "#!$PBANG --gnu -I _XML_ --ungroup --joblog $LOGDIR/$(basename $OUTPUT).log --bf $REMOTESCRIPT --bf $REMOTELOGGER $REMOTESCRIPT _XML_ $IMAGEJMEM \\\\\\\\| $REMOTELOGGER $OUTPUT" | tee "$OUTPUT"
  chmod +x "$OUTPUT"
 
  if [ "$RUN" == "true" -o "$RUN" == "yes" ] ; then
    # run in queue mode
    echo "#### running $OUTPUT" 1>&2
    doit | tee -a "$OUTPUT" | parallel --gnu -I _XML_ --ungroup --joblog $LOGDIR/$(basename $OUTPUT).log --bf $REMOTESCRIPT --bf $REMOTELOGGER $REMOTESCRIPT _XML_ $IMAGEJMEM \| $REMOTELOGGER $OUTPUT
   
  else
    # or generate output script
    doit | tee -a "$OUTPUT"
   
  fi
   
  echo "#### saved as $OUTPUT" 1>&2
   
}  

assertcommands() {
  while [ $# -ne 0 ] ; do
    local CMD=$1
    shift
    [ -z "$(which $CMD)" ] && echo command $CMD not found >&2 && exit 1
  done || true
}
 
checkdependencies() {
  assertcommands realpath parallel ssh
}
 
getTimestamps() {
  while read JP4 ; do
    # extract timestamps
    JP4=$(basename $JP4)
    echo ${JP4:0:17}
  done |
  sort -u |
  while read timestamp ; do
    # echo timestamp only if theres not yet 29 files with it
    if [ -z "$DSTDIRLIST" ] ; then
      export DSTDIRLIST=$(mktemp -u --tmpdir=/dev/shm)
      find  "$DSTDIR" -name \*EQR.tiff > $DSTDIRLIST
    fi                                                                                                                                                                                                           
    [ $(grep -E -e $timestamp.\*EQR.tiff $DSTDIRLIST 2>/dev/null | wc -l) -ne 29 ] && echo $timestamp
  done
}       

# return shuffled (progressive) timestamp list,                                                                                                                                                                    
# reducing the step by half recursively
shuffile() {
  argv=($(cat "$FILELIST" | getTimestamps))
  argc=${#argv[*]}
  last=$((argc - 1))
  [ $last -eq 0 ] && last=1
  step=$(expr $argc / 2)
  [ $step -eq 0 ] && step=1
  while true ; do
    for (( i=0; i<$argc ; i+=step )) ; do
      stamp="${argv[$i]}"
      if [ -n "$stamp" ] ; then
        argv[$i]=
        jp4_count=$(grep -e $stamp "$FILELIST" | wc -l)
        if [ $jp4_count -eq 9 ] ; then
          echo $stamp
        else
          echo "Warning: $stamp discarded (jp4 count is $jp4_count)" >&2
        fi
      fi
    done
    if [ -n "${argv[$last]}" ] ; then
      stamp=${argv[$last]}
      argv[$last]=
      jp4_count=$(grep -e $stamp "$FILELIST" | wc -l)
      if [ $jp4_count -eq 9 ] ; then
        echo $stamp
      else
        echo "Warning: $stamp discarded (jp4 count is $jp4_count)" >&2
      fi
    fi
    [ $step -eq 1 ] && break
    ((step/=2))
  done
}

# list files in SRCDIR if cached list not specified as FILELIST environment variable
getfilelist() {
  if [ -z "$FILELIST" ] ; then
    FILELIST="/tmp/filelist_$NOW.tmp"
    find "$SRCDIR" -maxdepth 2 -name \*.jp4 | sort > $FILELIST
  else
    echo "Using files listed in $FILELIST" 1>&2
  fi
  if [ -n "$SHUFFLE" ] ; then
    shuffile
  else
    cat "$FILELIST" | getTimestamps
  fi
}

# Generate and list imagej-elphel xml files
export COUNT=0
export FOLDER_NUM=0
doit() {
  if (( $SPLITAT > 9 )) ; then
    OUTXML=$SRCDIR/../post_processing/${NOW}.xml
    corrxml.sh $SHUFFLE $XML $SRCDIR $DSTDIR $OUTXML $SPLITAT
    find $(dirname $OUTXML) -maxdepth 1 -type f -name $(basename $OUTXML .xml)\* | sort
  else
    # FILELIST is also used in corrxml.sh
    export FILELIST
    getfilelist | while read TIMESTAMP ; do
      OUTXML=$SRCDIR/../post_processing/${NOW}-$TIMESTAMP.xml
      corrxml.sh $XML $SRCDIR $DSTDIR/$FOLDER_NUM $OUTXML $SPLITAT $TIMESTAMP $TRUNCATE
      find $(dirname $OUTXML) -maxdepth 1 -type f -name $(basename $OUTXML .xml)\* | sort
      ((COUNT+=SPLITAT))
      if [ $COUNT -ge $FOLDER_MAX ] ; then
        ((++FOLDER_NUM))
        COUNT=0
      fi
    done
  fi
}

main "$@"
